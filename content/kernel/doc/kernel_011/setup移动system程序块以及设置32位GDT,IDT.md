
# setup移动system程序块以及设置32位GDT,IDT

<h2 id = 'm'> 目录 </h2>

[教学视频](#t)

[1. 关闭中并移动SYSTEM代码](#1)

[2. 设置中断描述符表和全局描述符表](#2)

[直达底部](#e)

<h2 id = 't'> 教学视频 </h2>

[setup程序移动内核代码system程序块以及设置32位GDT,IDT](http://toutiao.com/item/6655667011739189767/ "setup程序移动内核代码system程序块以及设置32位GDT,IDT")

<h2 id = '1'> 1. 关闭中并移动SYSTEM代码 </h2>
  
  接下来， 操作系统要使计算机在 32 位保护模式下工作，这要做大量的重建工作， 并且持续工作到 操作系统的 main 函数的执行过程中。操作系统执行前期动作包括打开32位的寻址空间、打开保护模式、 建立保护模式下的中断响应机制等与保护模式配套的相关工作、建立内存的分页机制，最后做好 调用 main 函数的准备。

  SETUP第一个准备工作先要关闭中断，即将CPU的标志寄存器（EFLAGS） 中的中断允许标志（IF） 置 0。 这意味着， 程序在接下来的执行过程中， 无论是否发生中断， 系统都不再对此中断进行响应， 直到 main 函数中能够适应保护模式的中断服务体系被重建完毕才会打开中断， 而那时候响应 中断的服务程序将不再是 BIOS 提供的中断服务程序，取而代之的是由系统自身提供的中断服务程序。

![](https://i.imgur.com/nBtJdzs.png)

  关中断（cli）和开中断（sti）操作在操作系统代码中频繁出现，cli、sti 总是在一个完整操作过程的两头出现， 目的是避免中断在此期间的介入。 接下来的代码将为操作系统进入保护模式做准备。 此处即将进行实模式下中断向量表（IVT，BIOS提供）和保护模式下中断描述符表（IDT）的交接工作。 如果没有 cli，又恰好发生中断，中断就要切进来，就不得不面对实模式的中断机制已经废除、 保护模式的中断机制尚未完成的尴尬局面，结果就是系统崩溃。cli、sti 保证了这个过程中，IDT 能够完整创建，以避免不可预料中断的进入造成 IDT 创建不完整或新老中断机制混用。 


  下面，setup 程序做了一个影响深远的动作： <font color='red'> **将位于 0x10000 的内核 程序复制至内存地址起始位置 0x00000 处！** </font>

![](https://i.imgur.com/yBPEajF.png)

  移动后的内存布局如下

![](https://i.imgur.com/HxQSkqM.png)

  0x00000 这个位置原来存放着由 BIOS 建立的中断向量表(IVT) 及 BIOS 数据区。 这个复制动作 将 BIOS 中断向量表和 BIOS 数据区完全覆盖，使它们不复存在。 直到新的中断服务体系构建完毕 之前，操作系统不再具备响应并处理中断的能力。

  1. 废除 BIOS 的中断向量表，等同于废除了 BIOS 提供的实模式下的中断服务程序。
  2. 收回刚刚结束使用寿命的程序所占内存空间。
  3. 让内核代码占据内存物理地址最开始的、天然的、有利的位置（0x00000 开始的内存）。

  system 模块复制到 0x00000 这个动作，废除了 BIOS 的中断向量表，也就是废除了 16 位的中断 机制。操作系统是不能没有中断的，对外设的使用、系统调用、进程调度都离不开中断。Linux 操作系统是32位的现代操作系统，16位的中断机制对 32 位的操作系统而言， 显然是不合适的，这也是 废除16位中断机制的根本原因。为了建立32位的操作系统要建立新的32为中断机制。

[返回目录](#m)

<h2 id = '2'> 2. 设置中断描述符表和全局描述符表 </h2>

  setup 程序继续为保护模式做准备。此时要通过 setup 程序自身提供的数据信息对中断描述符表寄存器（IDTR）和 全局描述符表寄存器（GDTR）进行初始化设置。
  
> 知识点： GDT; LDT; GDTR; LDTR；IDT; IDTR <br/>
> 学习参考地址： [X86分段机制](https://blog.csdn.net/leoufung/article/details/86770794 "X86分段机制") </br>
> IDT（Interrupt Descriptor Table， 中断描述符表），保存保护模式下所有中断服务程序的入口 地址，类似于实模式下的中断向量表。<br>
> IDTR（Interrupt Descriptor Table Register, IDT基地址寄存器，保存IDT的起始地址。

加载GDT和LDT代码如下

![](https://i.imgur.com/mqeRyvM.png)

![](https://i.imgur.com/XqECv42.png)

  代码设置所需要的数据分别在 idt_48 和 gdt_48 所对应的标号处

内存布局如下

![](https://i.imgur.com/2Jy7xeV.png)

> 16位的中断机制用的是中断向量表，中断向量表的起始位置在 0x00000 处，这个位置是固定的；32位的中断机制用的是中断描述符表（IDT），位置是不固定的，可以由操作系统的设计者根据设计 要求灵活安排，由 IDTR 来锁定其位置。 <br/>

  此刻内核尚未真正运行起来，还没有进程，所以现在创建的 GDT 第一项为空，第二项为内核代码段 描述符，第三项为内核数据段描述符，其余项皆为空。

  IDT虽然已经设置，实为一张空表，原因是目前已关中断，无需调用中断服务程序。

  创建这两个表的过程可理解为是分两步进行的： <br/>
  1. 在设计内核代码时，已经将两个表写好，并且把需要的数据也写好。 <br/>
  2. 将专用寄存器（IDTR、 GDTR）指向表。<br/>
  

[返回目录](#m)
<p id = 'e'> </p>