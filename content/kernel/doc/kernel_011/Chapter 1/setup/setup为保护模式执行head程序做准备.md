
# setup程序为保护模式执行head程序做准备

<h2 id = 'm'> 目录 </h2>

[教学视频](#t)

[1. 编程8259A中断控制器](#1)

[2. 使能保护模式](#2)

[直达底部](#e)

<h2 id = 't'> 教学视频 </h2>

[Linux内核启动：setup程序为保护模式执行head程序做准备](http://toutiao.com/item/6655891445213299211/ "Linux内核启动：setup程序为保护模式执行head程序做准备")

<h2 id = '1'> 1. 编程8259A中断控制器 </h2>
  
  为了建立保护模式下的中断机制，setup 程序将对可编程中断控制器 8259A 进行重新编程（因为中断号和中断引脚需要重新映射）。

> 8259A： 专门为了对 8085A 和 8086/8088 进行中断控制而设计的芯片，是可以用程序控制的中断控制器。单个的 8259A 能管理8级向量优先级中断，在不增加其他电路的情况下，最多可以级联成64级的向量优先级中断系统。

具体代码如下：

![](https://i.imgur.com/aFUKLZu.png)

  CPU 在保护模式下，int0x00～int0x1F被 Intel 保留作为内部（不可屏蔽）中断和异常中断。如果不对 8259A 进行重新编程，int0x00～int0x1F中断将被覆盖。 例如， IRQ0（ 时钟 中断） 为 8 号（ int 0x08） 中断， 但在保护模式下此中断号是 Intel 保留 的“Double Fault”。 因此，必须通过8259A编程将原来的IRQ0x00～IRQ0x0F 对应的中断号重新分布， 即在保护模式下，IRQ0x00～IRQ0x0F的中断号是 int0x20(32) ～ int 0x2F(47)。 <br/>
<font color = red>**注意，只是分配的中断号发生了变化（变为从32开始），中断引脚连接没有变化，还是IRQ8连接实时时钟中断** </font>

编程后结果如下<br/>
![](https://i.imgur.com/IhfB25J.png)


[返回目录](#m)

<h2 id = '2'> 2. 使能保护模式 </h2>

  setup程序将CPU工作方式设为保护模式。将CR0寄存器第0位（PE）置 1，即设定处理器工作方式为 保护模式。

> CR0寄存器： 0号32位控制寄存器，存放系统控制标志。第0位为PE（Protected Mode Enable，保护模式使能）标志，置1时CPU工作在保护模式下，置0时为实模式。

![](https://i.imgur.com/b8a2AVr.png)

  代码如下
![](https://i.imgur.com/PTJTvPf.png)

  CPU 工作方式转变为保护模式，一个重要的特征就是要根据GDT决定后续执行哪里的程序。对GDT的设置都是setup事先安排好了的默认设置。现在从setup程序跳转到head程序

![](https://i.imgur.com/XNFnqic.png)

  这里对 jmpi  0,8 进行一下说明， 这一行代码中的“0” 是段内偏移，“8”是保护模式下的段选择符(段选择子，selector)，用于选择描述符表和描述符表项以及所要求的特权级。 这里“8” 的解读方式必须看成二进制的1000。

![](https://i.imgur.com/SUqSrzS.png)

![](https://i.imgur.com/JxOqWxJ.png)

  - **这里1000的最后两位（00）表示内核特权级，与之相对的用户特权级是11；第三位的0表示GDT，如果是1，则表示LDT；1000的1表示所选的表（在此就是GDT）的1项（GDT项号排序为0项、1项、2 项，这里也就是第2项）来确定代码段的段基址和段限长等信息。**<br/>
  - **可以看到从1项描述符内容， 代码是从段基址0x00000000、偏移为0处，也就是head程序的开始位置开始执行的，这意味着执行head 程序。**
 
  到这里为止，setup就执行完毕了，它为系统能够在保护模式下运行做了一系列的准备工作。但这些准备工作还不够，后续的准备工作将由head程序来完成。

[返回目录](#m)

<p id = 'e'> </p>