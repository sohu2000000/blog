# Linux内核启动：虚拟盘空间设置和内存管理结构初始化

<h2 id = 'm'> 目录 </h2>

[教学视频](#t)

[1. 设置虚拟盘并初始化](#1)

[2. 初始化内存管理结构mem_map](#2)

[直达底部](#e)

<h2 id = 't'> 教学视频 </h2>

[Linux内核启动：虚拟盘空间设置和内存管理结构初始化](http://toutiao.com/item/6657341101516521991/ "Linux内核启动：虚拟盘空间设置和内存管理结构初始化")

<h2 id = '1'> 1. 设置虚拟盘并初始化 </h2>

  接下来main函数将对外设中的虚拟盘区进行设置。 检查makefile文件中“虚拟盘使用标志”是否设置， 以此确定系统是否使用了虚拟盘（假设有虚拟盘，大小设置为2 MB）。 操作系统从缓冲区的末端起开辟2MB内存空间设置为虚拟盘，主内存起始位置后移2MB至虚拟盘的末端

![](https://i.imgur.com/rQ7VB4b.png)

  实现代码如下

![](https://i.imgur.com/MQ59zo4.png)

![](https://i.imgur.com/5Td81Ze.png)

![](https://i.imgur.com/cp0UPDy.png)

![](https://i.imgur.com/bBHxdXB.png)

![](https://i.imgur.com/GaWGxds.png)

![](https://i.imgur.com/nm35tTI.png)
 
  在rd\_init（）函数中，先要将虚拟盘区的请求项处理函数do_rd_request（）请求项函数控制结构blk_dev[7]的第二项挂接。 blk_dev[7]的主要功能是将某一类设备与它对应的请求项处理函数挂钩。 目前操作系统最多可以管理6类设备。 这个挂接动作意味着以后内核内核能够通过调用do_rd_request函数处理与虚拟盘相关的请求项操作。挂接之后，将虚拟盘所在的内存区域全部初始化为0。

![](https://i.imgur.com/dxXDXNG.png)

  最后将虚拟盘区的长度值返回。这个返回值将用来重新设置主内存区的起始位置。

[返回目录](#m)

<h2 id = '2'> 2. 初始化内存管理结构mem_map </h2>

  对主内存区起始位置的重新确定，标志着主内存区和缓冲区的位置和大小已经全都确定，系统 开始调用mem_init()函数。 先对主内存区的管理结构进行设置。

![](https://i.imgur.com/XZlKITJ.png)

  代码实现如下

![](https://i.imgur.com/I2fnZhr.png)

![](https://i.imgur.com/08BFdAI.png)

![](https://i.imgur.com/WKLE99H.png)

  系统通过mem_map[]对1MB以上的内存分页进行管理，记录一个页面的使用次数。 
  mem_init()函数先将所有的内存页面使用计数均设置成USED（100，即被使用），然后再将主 内存中的所有页面使用计数全部清零，系统以后只把使用计数为0的页面视为空闲页面。系统不对1MB以内的内存空间用这种分页方法管理，是因为操作系统对内核和用户进程采用了两套不同 的分页管理方法。内核采用分页管理方法，线性地址和物理地址是完全一样的，是一一映射的，等价于内核可以直接获得物理地址。用户进程线性地址和物理地址差异很大，之间没有可递推的 逻辑关系。操作系统目的就是让用户进程无法通过线性地址推算出具体的物理地址，让内核能够 访问用户进程，用户进程不能访问其他的用户进程，更不能访问内核。 1MB以内是内核代码和 只有由内核管控的大部分数据所在内存空间，是绝对不允许用户进程访问的。 1MB以上，特别是 主内存区主要是用户进程的代码、数据所在内存空间，所以采用专门用来管理用户进程的分页管理方法。

[返回目录](#m)

<p id = 'e'> </p>