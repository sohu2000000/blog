
# BIOS 加电启动原理

<h2 id = 'm'> 目录 </h2>

[教学视频](#t)

[0. 背景描述](#0)

[1.上电加载三部曲](#1)

[2. 什么是实模式](#2)

[3. 启动BIOS，准备实模式下的中断向量表和中断服务程序](#3)

[直达底部](#e)

<h2 id = 't'> 教学视频 </h2>

[BIOS上电过程, BIOS内存布局，BIOS加载中断向量表和中断服务程序](http://toutiao.com/item/6655158216139211278/ "BIOS上电过程, BIOS内存布局，BIOS加载中断向量表和中断服务程序")

<h2 id = '0'> 0. 背景描述 </h2>
-  X86 32bit cpu
-  内核采用 Linux Kernel 0.11 版本
-  使用 qemu 模拟器进行， seabios 作为启动调试代码

<h2 id = '1'> 1.上电加载三部曲 </h2>

1. 第一部： 启动BIOS， 准备实模式下的中断向量表和中断服务程序； 
2. 第二部： 从启动盘加载操作系统程序到内存，加载操作系统程序的工作就是利用第一步中准备的中断服务程序实现的； 
3. 第三部： 为执行32位的内核入口main函数做过渡工作

<h2 id = '2'> 2. 什么是实模式 </h2>

  实模式（Real Mode）是Intel 80286 和之后的 80x86 兼容 CPU 的操作模式（应该包括 8086）。 实模式的特性是一个20位的存储器地址空间（ 2^ 20= 1048576， 即 1 MB 的存储器可被寻址）， 可以直接软件访问 BIOS 以及周边硬件， 没有硬件支持的分页机制和实时多任务概念。 从80286开始， 所有的 80x86 CPU 的开机状态都是实模式； 8086等早期的CPU只有一种操作模式，类似于实模式。

<h2 id= '3'> 3. 启动BIOS，准备实模式下的中断向量表和中断服务程序 </h2>

-   内存RAM内没有数据，系统代码在磁盘中，CPU的逻辑电路被设计为只能从内存中运行操作系统
-   必须将软盘中的操作系统程序加载到内存（ RAM）中，才可执行
-   在 BIOS 中设置软驱/硬盘为启动设备。
-   在 RAM 中什么程序也没有的时候， BIOS完成加载软盘/硬盘中操作系统的任务

<h3 id='3.1'> 3.1 BIOS启动原理 </h3>
  依靠硬件方式，BIOS 通过从定义好的固定地址 0XFFFF0开始执行系统代码
  Intel 将所有 80x86 系列的 CPU 都设计为加电即进入 16 位实模式状态运行， 将 CPU 硬件逻辑设计为加电瞬间强行将 CS 的值置为 0xF000、 IP 的值置为0xFFF0， 这样 CS： IP 就指向 0xFFFF0 这个地址位置。
  BIOS程序的入口地址正好是0xFFFF0

![BIOS启动上电内存状态](https://i.imgur.com/cPdUHpf.png)

<h3 id='3.1'> 3.2 BIOS加载内存中断向量表和中断服务程序 </h3>
  BIOS程序被固化在主机板一块很小的ROM芯片里。一系列检测过后，是 BIOS 在内存中建立中断向量表和中断服务程序。

  BIOS 程序在内存最开始的位置（ 0x00000）用 1 KB 的内存空间（ 0x00000 ～ 0x003FF）构建 中断向量表， 在紧挨着它的位置用 256 字节的内存空间构建 BIOS 数据区（ 0x00400 ～ 0x004FF）， 并在大约 57 KB 以后的位置（ 0x0E05B） 加载了 8 KB 左右的与中断向量表相应 的若干中断服务程序。
> 0x00100 是256字节， 0x00400就是 4 × 256 字节 = 1024字节， 也就是 1 KB。

![BIOS加载中断向量表和中断服务程序](https://i.imgur.com/73QqMPY.png)

  BIOS 中断向量表中有 256 个中断向量， 每个中断向量占4字节， 其中两个字节是 CS 的值，两个 字节是 IP 的值。 每个中断向量都指向一个具体的中断服务程序。

<p id = 'e'> </p>